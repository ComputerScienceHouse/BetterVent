package edu.rit.csh.bettervent

import android.content.Context
import android.content.SharedPreferences
import android.os.Bundle
import androidx.fragment.app.Fragment
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup

import kotlinx.android.synthetic.main.fragment_status.*
import kotlinx.android.synthetic.main.password_alert.view.*
import org.jetbrains.anko.alert
import org.jetbrains.anko.noButton
import org.jetbrains.anko.yesButton

import java.text.SimpleDateFormat
import java.util.*
import kotlin.collections.ArrayList
import kotlin.system.exitProcess

class StatusFragment : Fragment(){

    private lateinit var appSettings: SharedPreferences // Settings object containing user preferences.
    private lateinit var events: ArrayList<Event>
    private lateinit var listener: OpenSettingsListener

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? {
        infoPrint("Loaded Status Fragment.")

        return inflater.inflate(R.layout.fragment_status, container, false)
    }

    /**
     * @param view
     * @param savedInstanceState
     */
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        // Load up app settings to fetch passwords and background colors.
        appSettings = context!!.getSharedPreferences(
                getString(R.string.preference_file_key), Context.MODE_PRIVATE)

        events = arguments?.getParcelableArrayList<Event>("events")!!

        EventActivity.centralClock.setTextColor(-0x1)

        fun showAlertWithFunction(onSuccess: () -> Unit) {
            context?.alert("Enter Password:") {
                val v = layoutInflater.inflate(R.layout.password_alert, null)
                customView = v
                fun checkPassword(pw: String) {
                    if (pw == appSettings.getString("edu.rit.csh.bettervent.password", "")) onSuccess()
                }
                yesButton { checkPassword(v.password_et.text.toString()) }
                noButton { dialog -> dialog.cancel() }
            }?.show()
        }

        leave_button.setOnClickListener {
            showAlertWithFunction { exitProcess(0) }
        }

        settings_button.setOnClickListener {
            showAlertWithFunction { listener.openSettings() }
        }
        updateCurrentAndNextEventsInUI()
    }

    override fun onAttach(context: Context) {
        context.let { super.onAttach(it)
            if (it is OpenSettingsListener) {
                listener = it
            } else {
                throw ClassCastException("$it must implement OpenSettingsListener.")
            }
        }
    }

    /**
     * Looks at the APIOutList (the List of Events generated by the API),
     * and based on how many there are and when they are, sets the string
     * values for currentEventTitle, currentEventTime, nextEventTitle, and
     * nextEventTime.
     */

    private fun updateCurrentAndNextEventsInUI() {

        events.also {
            when {
                it.isEmpty() -> {
                    setRoomAsEmpty(); setNoNextEvent()
                }
                it.size == 1 ->  if (it[0].isHappeningNow()) setCurrentEvent(it[0]) else setNextEvent(it[0])
                else -> {
                    if (it[0].isHappeningNow()){
                        setCurrentEvent(it[0])
                        setNextEvent(it[1])
                    } else {
                        setRoomAsEmpty()
                        setNextEvent(it[0])
                    }
                }
            }
        }
    }

    private fun setRoomAsEmpty(){
        free_label.visibility = View.VISIBLE
        reserved_label.visibility = View.INVISIBLE
        event_title.text = ""
        event_time.text = ""
        status_layout.setBackgroundColor(resources.getColor(R.color.CSHGreen))
    }

    private fun setNoNextEvent(){
        next_label.visibility = View.INVISIBLE
        next_event_time.text = ""
        next_event_title.text = "There are no upcoming events."
    }

    private fun setCurrentEvent(e: Event){
        free_label.visibility = View.INVISIBLE
        reserved_label.visibility = View.VISIBLE
        event_title.text = e.summary
        event_time.text = "${formatDate(e.start)} - ${formatDate(e.end)}"
        status_layout.setBackgroundColor(resources.getColor(R.color.CSHRed))
    }

    private fun setNextEvent(e: Event){
        next_label.visibility = View.VISIBLE
        next_event_time.text = "${formatDate(e.start)} - ${formatDate(e.end)}"
        next_event_title.text = e.summary
    }

    /**
     * Method to format DateTimes into human-readable strings
     *
     * @param dateTime: DateTime to make readable
     * @return: HH:MM on YYYY/MM/DD
     */
    private fun formatDate(inputDate: Date): String {
        val simpleTimeFormat = SimpleDateFormat("HH:mm", Locale.getDefault())
        val simpleDateFormat = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
        val time = simpleTimeFormat.format(inputDate)
        val date = simpleDateFormat.format(inputDate)
        return "$time on $date"
    }

    private fun infoPrint(info: String) {
        println("STAT_: $info")
    }
}

interface OpenSettingsListener{
    fun openSettings()
}