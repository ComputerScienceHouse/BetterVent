package edu.rit.csh.bettervent

import android.accounts.Account
import android.app.admin.DevicePolicyManager
import android.content.ComponentName
import android.support.design.widget.BottomNavigationView
import android.support.design.widget.FloatingActionButton
import android.support.v4.app.Fragment
import android.support.v7.app.AppCompatActivity
import android.os.Bundle
import android.view.MenuItem

import com.google.api.client.googleapis.extensions.android.gms.auth.GoogleAccountCredential

import android.accounts.AccountManager
import android.app.Activity
import android.app.Dialog
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.net.ConnectivityManager
import android.net.NetworkInfo
import android.os.Handler
import android.view.View
import android.widget.TextClock
import android.widget.Toast

import com.google.android.gms.common.ConnectionResult
import com.google.android.gms.common.GooglePlayServicesUtil
import com.google.api.client.extensions.android.http.AndroidHttp
import com.google.api.client.http.HttpTransport
import com.google.api.client.json.JsonFactory
import com.google.api.client.json.gson.GsonFactory
import com.google.api.client.util.DateTime
import com.google.api.client.util.ExponentialBackOff
import com.google.api.services.calendar.CalendarScopes
import com.google.api.services.calendar.model.*

import java.lang.reflect.Array
import java.util.ArrayList
import java.util.Arrays

class MainActivity : AppCompatActivity() {

    internal lateinit var mService: com.google.api.services.calendar.Calendar

    internal lateinit var credential: GoogleAccountCredential
    // This MainActivity gets the data from the API, and holds it
    // as a list. The Fragments then update themselves using that.
    private val APIOutList = ArrayList<Event>()
    internal val transport = AndroidHttp.newCompatibleTransport()
    internal val jsonFactory: JsonFactory = GsonFactory.getDefaultInstance()
    var calendarID: String? = null
    var maxResults: Int = 0

    private var mAppSettings: SharedPreferences? = null

    private lateinit var APIStatusMessage: String
    var isReserved = true
    private lateinit var bottomNav: BottomNavigationView
    private lateinit var refreshButton: FloatingActionButton

    private val navListener = BottomNavigationView.OnNavigationItemSelectedListener { item ->
        selectedFragment = null
        when (item.itemId) {
            R.id.navigation_status ->
                //                            selectedFragment = new StatusFragment();
                selectedFragment = StatusFragment.newInstance(APIOutList)
            R.id.navigation_schedule -> selectedFragment = ScheduleFragment.newInstance(APIOutList)
            R.id.navigation_quick_mode -> selectedFragment = QuickModeFragment()
        }

        //                    System.out.println("*** currentEventTitle: " + currentEventTitle);
        supportFragmentManager.beginTransaction().replace(R.id.fragment_container,
                selectedFragment!!).commit()

        true
    }

    /**
     * Checks whether the device currently has a network connection.
     * @return true if the device has a network connection, false otherwise.
     */
    private val isDeviceOnline: Boolean
        get() {
            val connMgr = getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
            val networkInfo = connMgr.activeNetworkInfo
            return networkInfo != null && networkInfo.isConnected
        }

    /**
     * Check that Google Play services APK is installed and up to date. Will
     * launch an error dialog for the user to update Google Play Services if
     * possible.
     * @return true if Google Play Services is available and up to
     * date on this device; false otherwise.
     */
    private val isGooglePlayServicesAvailable: Boolean
        get() {
            val connectionStatusCode = GooglePlayServicesUtil.isGooglePlayServicesAvailable(this)
            if (GooglePlayServicesUtil.isUserRecoverableError(connectionStatusCode)) {
                showGooglePlayServicesAvailabilityErrorDialog(connectionStatusCode)
                return false
            } else if (connectionStatusCode != ConnectionResult.SUCCESS) {
                return false
            }
            return true
        }


    /**
     * Checks the times of the first event in APIOutList (the List of Events generated by the API)
     * and if the current time is within those times, then the room is booked
     * and if the current time is not within those times, the room is free.
     * @return: true if the current time is outside of the time of the
     * next event, and false if vice-versa.
     */
    private// Then the room is currently in use.
    // If something weird happens, just assume the room is free.
    val isFree: Boolean
        get() {
            try {
                val now = DateTime(System.currentTimeMillis())
                val firstEventStart = APIOutList[0].start.dateTime
                val firstEventEnd = APIOutList[0].end.dateTime
                if (now.value > firstEventStart.value && now.value < firstEventEnd.value) {
                    isReserved = true
                    return false
                } else {
                    isReserved = false
                    return true
                }
            } catch (e: Exception) {
                isReserved = false
                return true
            }

        }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)


        // Load up app settings to fetch passwords and background colors.
        mAppSettings = getSharedPreferences(
                getString(R.string.preference_file_key), Context.MODE_PRIVATE)

        // Must restart for these preferences to take hold.
        calendarID = mAppSettings!!.getString("edu.rit.csh.bettervent.calendarid", "")
        val maxResultsStr = mAppSettings!!.getString("edu.rit.csh.bettervent.maxresults", "")
        if (maxResultsStr !== "" && maxResultsStr != null)
            maxResults = Integer.parseInt(maxResultsStr)
        else {
            infoPrint("Max Results not set. Defaulting to 100.")
            maxResults = 100
        }


        //Following code allow the app packages to lock task in true kiosk mode
        // get policy manager
        val myDevicePolicyManager = getSystemService(Context.DEVICE_POLICY_SERVICE) as DevicePolicyManager
        // get this app package name
        val mDPM = ComponentName(this, AdminReceiver::class.java)

        if (myDevicePolicyManager.isDeviceOwnerApp(this.packageName)) {
            // get this app package name
            val packages = arrayOf(this.packageName)
            // mDPM is the admin package, and allow the specified packages to lock task
            myDevicePolicyManager.setLockTaskPackages(mDPM, packages)
        } else {
            Toast.makeText(applicationContext, "Not owner", Toast.LENGTH_LONG).show()
        }

        startLockTask()


        bottomNav = findViewById(R.id.bottom_navigation)
        bottomNav.setOnNavigationItemSelectedListener(navListener)

        refreshButton = findViewById(R.id.refresh_button)

        refreshButton.setOnClickListener {
            // TODO: figure out why you have to do this twice to make anything happen.
            refreshResults()
            refreshUI()
        }

        // Initialize credentials and service object.
        val settings = getPreferences(Context.MODE_PRIVATE)
        credential = GoogleAccountCredential.usingOAuth2(
                applicationContext, Arrays.asList(*SCOPES))
                .setBackOff(ExponentialBackOff())
                .setSelectedAccountName(settings.getString(PREF_ACCOUNT_NAME, null))

        mService = com.google.api.services.calendar.Calendar.Builder(
                transport, jsonFactory, credential)
                .setApplicationName("Google Calendar API Android Quickstart")
                .build()

        refreshResults()
        if (selectedFragment == null) {
            selectedFragment = StatusFragment.newInstance(APIOutList)
            supportFragmentManager.beginTransaction().replace(R.id.fragment_container,
                    selectedFragment!!).commit()
        }

        centralClock = findViewById(R.id.central_clock)

        // Initialize API Refresher. Make sure to sign into a google account before launching the app.
        val handler = Handler()
        val runnable = object : Runnable {
            override fun run() {
                if (credential.selectedAccountName != null) {
                    refreshResults()
                    println(" *** Refreshed.")
                    refreshUI()
                    handler.postDelayed(this, 10000)
                }
            }
        }

        //Start API Refresher
        handler.postDelayed(runnable, 1000)

    }

    /**
     * Called whenever this activity is pushed to the foreground, such as after
     * a call to onCreate().
     */
    override fun onResume() {
        super.onResume()
        if (isGooglePlayServicesAvailable) {
            refreshResults()
        } else {
            APIStatusMessage = "Google Play Services required: " + "after installing, close and relaunch this app."
        }
    }

    /**
     * Called when an activity launched here (specifically, AccountPicker
     * and authorization) exits, giving you the requestCode you started it with,
     * the resultCode it returned, and any additional data from it.
     * @param requestCode code indicating which activity result is incoming.
     * @param resultCode code indicating the result of the incoming
     * activity result.
     * @param data Intent (containing result data) returned by incoming
     * activity result.
     */
    override fun onActivityResult(
            requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        infoPrint("API Request code returned: $requestCode")
        when (requestCode) {
            REQUEST_GOOGLE_PLAY_SERVICES -> if (resultCode == Activity.RESULT_OK) {
                refreshResults()
            } else {
                isGooglePlayServicesAvailable
            }
            REQUEST_ACCOUNT_PICKER -> {
                infoPrint("Pick your account.")
                if (resultCode == Activity.RESULT_OK && data != null &&
                        data.extras != null) {
                    infoPrint("Result = $resultCode")
                    val accountName = data.getStringExtra(AccountManager.KEY_ACCOUNT_NAME)
                    infoPrint("Account name = " + accountName!!)
                    if (accountName != null) {
                        //                        credential.setSelectedAccountName(accountName);
                        credential.selectedAccount = Account(accountName, "edu.rit.csh.bettervent")
                        infoPrint("Account name set. Account name = $accountName")
                        infoPrint(credential.selectedAccountName)
                        val settings = getPreferences(Context.MODE_PRIVATE)
                        val editor = settings.edit()
                        editor.putString(PREF_ACCOUNT_NAME, accountName)
                        editor.commit()
                        refreshResults()
                    }
                } else if (resultCode == Activity.RESULT_CANCELED) {
                    infoPrint("Account Unspecified")
                    APIStatusMessage = "Account unspecified."
                }
            }
            REQUEST_AUTHORIZATION -> if (resultCode == Activity.RESULT_OK) {
                if (credential.selectedAccountName.length < 1)
                    refreshResults()
            } else {
                chooseAccount()
            }
        }

        super.onActivityResult(requestCode, resultCode, data)
    }

    /**
     * Attempt to get a set of data from the Google Calendar API to display. If the
     * email address isn't known yet, then call chooseAccount() method so the
     * user can pick an account.
     */
    private fun refreshResults() {
        println("*** Refreshing results... ***")
        if (credential.selectedAccountName == null) {
            infoPrint("No account selected.")
            chooseAccount()
        } else {
            if (isDeviceOnline) {
                println("*** Executing APIAsyncTask. ***")
                ApiAsyncTask(this).execute()
                // TODO: java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState ???
            } else {
                println("*** Can't refresh calendar. ***")
                APIStatusMessage = "No network connection available."
            }
        }
    }

    fun refreshUI() {
        try {
            when (selectedFragment!!.javaClass){
                StatusFragment::class.java -> {
                    selectedFragment = StatusFragment.newInstance(APIOutList)
                    supportFragmentManager.beginTransaction().replace(R.id.fragment_container,
                            selectedFragment!!).commit()
                    println(" *** Refreshed Status UI")
                }
                ScheduleFragment::class.java -> {
                    selectedFragment = ScheduleFragment.newInstance(APIOutList)
                    supportFragmentManager.beginTransaction().replace(R.id.fragment_container,
                            selectedFragment!!).commit()
                    println(" *** Refreshed Schedule UI")
                }
                else -> println(" *** UI is not status.")
            }
        } catch (e: Exception) {
            System.err.println("Caught Exception\n$e")
        }

    }

    /**
     * Clear any existing Google Calendar API data from the TextView and update
     * the header message; called from background threads and async tasks
     * that need to update the UI (in the UI thread).
     */
    fun clearResultsText() {
        runOnUiThread {
            APIStatusMessage = "Retrieving data…"
            APIStatusMessage = ""
        }
    }

    /**
     * Fill the data TextView with the given List of Strings; called from
     * background threads and async tasks that need to update the UI (in the
     * UI thread).
     * @param dataEvents a List of Strings to populate the main TextView with.
     */
    fun updateResultsText(dataEvents: List<Event>?) {
        runOnUiThread {
            if (dataEvents == null) {
                APIStatusMessage = "Error retrieving data!"
            } else if (dataEvents.size == 0) {
                APIStatusMessage = "No data found."
                println("*** No data found. ***")
                APIOutList.removeAll(APIOutList)
            } else {
                APIStatusMessage = "API Call Complete."
                infoPrint("*** Events found.  *** $dataEvents")
                val eventKeyword = mAppSettings!!.getString("edu.rit.csh.bettervent.filterkeywords", "")
                APIOutList.removeAll(APIOutList)
                var eventFieldToCheck: String?
                for (event in dataEvents) {
                    if (mAppSettings!!.getBoolean("edu.rit.csh.bettervent.filterbytitle", false)) {
                        eventFieldToCheck = event.summary
                    } else {
                        eventFieldToCheck = event.location
                    }
                    infoPrint(eventFieldToCheck)
                    if (eventKeyword!!.length > 0 && eventFieldToCheck != null) {
                        if (eventFieldToCheck.toLowerCase().contains(eventKeyword.toLowerCase())) {
                            APIOutList.add(event)
                        }
                    } else if (eventKeyword.length < 1) {
                        APIOutList.add(event)
                    }
                }
                isFree
            }
        }
    }

    /**
     * Show a status message in the list header TextView; called from background
     * threads and async tasks that need to update the UI (in the UI thread).
     * @param message a String to display in the UI header TextView.
     */
    fun updateStatus(message: String) {
        runOnUiThread { APIStatusMessage = message }
    }

    /**
     * Starts an activity in Google Play Services so the user can pick an
     * account.
     */
    private fun chooseAccount() {
        startActivityForResult(
                credential.newChooseAccountIntent(), REQUEST_ACCOUNT_PICKER)
    }

    /**
     * Display an error dialog showing that Google Play Services is missing
     * or out of date.
     * @param connectionStatusCode code describing the presence (or lack of)
     * Google Play Services on this device.
     */
    internal fun showGooglePlayServicesAvailabilityErrorDialog(
            connectionStatusCode: Int) {
        runOnUiThread {
            val dialog = GooglePlayServicesUtil.getErrorDialog(
                    connectionStatusCode,
                    this@MainActivity,
                    REQUEST_GOOGLE_PLAY_SERVICES)
            dialog.show()
        }
    }

    private fun infoPrint(info: Any?) {
        if (info != null)
        println("MAIN_: " + info!!)
        else println("MAIN_: null!?!?!?")
    }

    companion object {

        internal val REQUEST_ACCOUNT_PICKER = 1000
        internal val REQUEST_AUTHORIZATION = 1001
        internal val REQUEST_GOOGLE_PLAY_SERVICES = 1002
        private val PREF_ACCOUNT_NAME = "accountName"
        private val SCOPES = arrayOf(CalendarScopes.CALENDAR_READONLY)

        lateinit var centralClock: TextClock

        //UI Elements visible throughout the app
        var selectedFragment: Fragment? = null
    }

}