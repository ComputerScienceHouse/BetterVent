package edu.rit.csh.bettervent

import android.accounts.Account
import android.app.admin.DevicePolicyManager
import android.content.ComponentName
import com.google.android.material.floatingactionbutton.FloatingActionButton
import androidx.fragment.app.Fragment
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle

import com.google.api.client.googleapis.extensions.android.gms.auth.GoogleAccountCredential

import android.accounts.AccountManager
import android.app.Activity
import androidx.lifecycle.Observer
import androidx.lifecycle.ViewModelProviders
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.net.ConnectivityManager
import android.os.Handler
import android.os.Parcelable
import android.util.Log
import androidx.fragment.app.FragmentManager
import androidx.fragment.app.FragmentStatePagerAdapter
import android.widget.TextClock
import android.widget.Toast
import com.google.android.gms.auth.api.signin.GoogleSignIn
import com.google.android.gms.auth.api.signin.GoogleSignInAccount
import com.google.android.gms.auth.api.signin.GoogleSignInOptions

import com.google.android.gms.common.ConnectionResult
import com.google.android.gms.common.GooglePlayServicesUtil
import com.google.android.gms.common.api.ApiException
import com.google.android.gms.tasks.Task
import com.google.api.client.extensions.android.http.AndroidHttp
import com.google.api.client.json.JsonFactory
import com.google.api.client.json.gson.GsonFactory
import com.google.api.client.util.DateTime
import com.google.api.client.util.ExponentialBackOff
import com.google.api.services.calendar.CalendarScopes
import kotlinx.android.parcel.Parcelize
import kotlinx.android.synthetic.main.activity_main.*
import java.text.SimpleDateFormat
import java.util.*

class MainActivity : AppCompatActivity(), OpenSettingsListener {
    override fun openSettings() {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }

    internal lateinit var mService: com.google.api.services.calendar.Calendar

    internal lateinit var credential: GoogleAccountCredential
    // This MainActivity gets the data from the API, and holds it
    // as a list. The Fragments then update themselves using that.
    private lateinit var model: MainActivityViewModel
    private lateinit var statusFragment: StatusFragment
    private lateinit var scheduleFragment: ScheduleFragment
    private lateinit var quickModeFragment: QuickModeFragment

    private val APIOutList = ArrayList<Event>()
    internal val transport = AndroidHttp.newCompatibleTransport()
    internal val jsonFactory: JsonFactory = GsonFactory.getDefaultInstance()
    var calendarID: String? = null
    var maxResults: Int = 0

    private var mAppSettings: SharedPreferences? = null

    private lateinit var APIStatusMessage: String
    var isReserved = true
    private lateinit var refreshButton: FloatingActionButton

    private lateinit var fragments: List<Fragment>
    private lateinit var account: GoogleSignInAccount
    private lateinit var mGoogleSignInClient: GoogleSignInAccount
    private lateinit var gso: GoogleSignInOptions

    /**
     * Checks whether the device currently has a network connection.
     * @return true if the device has a network connection, false otherwise.
     */
    private val isDeviceOnline: Boolean
        get() {
            val connMgr = getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
            val networkInfo = connMgr.activeNetworkInfo
            return networkInfo != null && networkInfo.isConnected
        }

    /**
     * Check that Google Play services APK is installed and up to date. Will
     * launch an error dialog for the user to update Google Play Services if
     * possible.
     * @return true if Google Play Services is available and up to
     * date on this device; false otherwise.
     */
    private val isGooglePlayServicesAvailable: Boolean
        get() {
            val connectionStatusCode = GooglePlayServicesUtil.isGooglePlayServicesAvailable(this)
            if (GooglePlayServicesUtil.isUserRecoverableError(connectionStatusCode)) {
                showGooglePlayServicesAvailabilityErrorDialog(connectionStatusCode)
                return false
            } else if (connectionStatusCode != ConnectionResult.SUCCESS) {
                return false
            }
            return true
        }




    /**
     * Checks the times of the first event in APIOutList (the List of Events generated by the API)
     * and if the current time is within those times, then the room is booked
     * and if the current time is not within those times, the room is free.
     * @return: true if the current time is outside of the time of the
     * next event, and false if vice-versa.
     */


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main_loading)

        gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
                .requestEmail()
                .build()

        model = ViewModelProviders.of(this)[MainActivityViewModel::class.java]
        model.getEvents().observe(this, Observer<ArrayList<Event>> {  events ->
            setupMainView(events)
        })


        // Load up app settings to fetch passwords and background colors.
        mAppSettings = getSharedPreferences(
                getString(R.string.preference_file_key), Context.MODE_PRIVATE)

        // Must restart for these preferences to take hold.
        calendarID = mAppSettings!!.getString("edu.rit.csh.bettervent.calendarid", "")
        val maxResultsStr = mAppSettings!!.getString("edu.rit.csh.bettervent.maxresults", "")
        if (maxResultsStr !== "" && maxResultsStr != null)
            maxResults = Integer.parseInt(maxResultsStr)
        else {
            infoPrint("Max Results not set. Defaulting to 100.")
            maxResults = 100
        }


        //Following code allow the app packages to lock task in true kiosk mode
        // get policy manager
        val myDevicePolicyManager = getSystemService(Context.DEVICE_POLICY_SERVICE) as DevicePolicyManager
        // get this app package name
        val mDPM = ComponentName(this, AdminReceiver::class.java)

        if (myDevicePolicyManager.isDeviceOwnerApp(this.packageName)) {
            // get this app package name
            val packages = arrayOf(this.packageName)
            // mDPM is the admin package, and allow the specified packages to lock task
            myDevicePolicyManager.setLockTaskPackages(mDPM, packages)
        } else {
            Toast.makeText(applicationContext, "Not owner", Toast.LENGTH_LONG).show()
        }

        startLockTask()

        // Initialize credentials and service object.
        val settings = getPreferences(Context.MODE_PRIVATE)


        refreshResults()


    }

    private fun setupMainView(events: ArrayList<Event>){
        refreshButton = findViewById(R.id.refresh_button)
        refreshButton.setOnClickListener {
            // TODO: figure out why you have to do this twice to make anything happen.
            refreshResults()
        }

        pager.adapter = SlidingPagerAdapter(supportFragmentManager)
        centralClock = findViewById(R.id.central_clock)

        val bundle = Bundle()
        bundle.putParcelableArrayList("events", events)
        statusFragment = StatusFragment()
        statusFragment.arguments = bundle
        scheduleFragment = ScheduleFragment()
        quickModeFragment = QuickModeFragment()
        fragments = listOf(statusFragment, scheduleFragment, quickModeFragment)
    }

    /**
     * Called whenever this activity is pushed to the foreground, such as after
     * a call to onCreate().
     */
    override fun onResume() {
        super.onResume()
        if (isGooglePlayServicesAvailable) {
            refreshResults()
        } else {
            APIStatusMessage = "Google Play Services required: " + "after installing, close and relaunch this app."
        }
    }

    /**
     * Called when an activity launched here (specifically, AccountPicker
     * and authorization) exits, giving you the requestCode you started it with,
     * the resultCode it returned, and any additional data from it.
     * @param requestCode code indicating which activity result is incoming.
     * @param resultCode code indicating the result of the incoming
     * activity result.
     * @param data Intent (containing result data) returned by incoming
     * activity result.
     */
    override fun onActivityResult(
            requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        infoPrint("API Request code returned: $requestCode")
        when (requestCode) {
            REQUEST_GOOGLE_PLAY_SERVICES -> if (resultCode == Activity.RESULT_OK) {
                refreshResults()
            } else {
                isGooglePlayServicesAvailable
            }
            REQUEST_ACCOUNT_PICKER -> {
                infoPrint("Pick your account.")
                if (resultCode == Activity.RESULT_OK && data != null &&
                        data.extras != null) {
                    infoPrint("Result = $resultCode")
                    val accountName = data.getStringExtra(AccountManager.KEY_ACCOUNT_NAME)
                    infoPrint("Account name = " + accountName!!)
                    //                        credential.setSelectedAccountName(accountName);
                    credential.selectedAccount = Account(accountName, "edu.rit.csh.bettervent")
                    infoPrint("Account name set. Account name = $accountName")
                    infoPrint(credential.selectedAccountName)
                    val settings = getPreferences(Context.MODE_PRIVATE)
                    val editor = settings.edit()
                    editor.putString(PREF_ACCOUNT_NAME, accountName)
                    editor.apply()
                    refreshResults()
                } else if (resultCode == Activity.RESULT_CANCELED) {
                    infoPrint("Account Unspecified")
                    APIStatusMessage = "Account unspecified."
                }
            }
            REQUEST_AUTHORIZATION -> if (resultCode == Activity.RESULT_OK) {
                if (credential.selectedAccountName.length < 1)
                    refreshResults()
            } else {
                chooseAccount()
            }
        }

        super.onActivityResult(requestCode, resultCode, data)
    }

    /**
     * Attempt to get a set of data from the Google Calendar API to display. If the
     * email address isn't known yet, then call chooseAccount() method so the
     * user can pick an account.
     */
    private fun refreshResults() {
        println("*** Refreshing results... ***")
        if (credential.selectedAccountName == null) {
            infoPrint("No account selected.")
            chooseAccount()
        } else {
            if (isDeviceOnline) {
                println("*** Executing APIAsyncTask. ***")
                ApiAsyncTask(this).execute()
                // TODO: java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState ???
            } else {
                println("*** Can't refresh calendar. ***")
                APIStatusMessage = "No network connection available."
            }
        }
    }


    /**
     * Clear any existing Google Calendar API data from the TextView and update
     * the header message; called from background threads and async tasks
     * that need to update the UI (in the UI thread).
     */
    fun clearResultsText() {
        runOnUiThread {
            APIStatusMessage = "Retrieving data…"
            APIStatusMessage = ""
        }
    }

    /**
     * Fill the data TextView with the given List of Strings; called from
     * background threads and async tasks that need to update the UI (in the
     * UI thread).
     * @param dataEvents a List of Strings to populate the main TextView with.
     */
    fun updateResultsText(dataEvents: List<Event>?) {
        runOnUiThread {
            if (dataEvents == null) {
                APIStatusMessage = "Error retrieving data!"
            } else if (dataEvents.size == 0) {
                APIStatusMessage = "No data found."
                println("*** No data found. ***")
                APIOutList.removeAll(APIOutList)
            } else {
                APIStatusMessage = "API Call Complete."
                infoPrint("*** Events found.  *** $dataEvents")
                val eventKeyword = mAppSettings!!.getString("edu.rit.csh.bettervent.filterkeywords", "")
                APIOutList.removeAll(APIOutList)
                var eventFieldToCheck: String?
                for (event in dataEvents) {
                    if (mAppSettings!!.getBoolean("edu.rit.csh.bettervent.filterbytitle", false)) {
                        eventFieldToCheck = event.summary
                    } else {
                        eventFieldToCheck = event.location
                    }
                    infoPrint(eventFieldToCheck)
                    if (eventKeyword!!.length > 0 && eventFieldToCheck != null) {
                        if (eventFieldToCheck.toLowerCase().contains(eventKeyword.toLowerCase())) {
                            APIOutList.add(event)
                        }
                    } else if (eventKeyword.length < 1) {
                        APIOutList.add(event)
                    }
                }
            }
        }
    }

    /**
     * Show a status message in the list header TextView; called from background
     * threads and async tasks that need to update the UI (in the UI thread).
     * @param message a String to display in the UI header TextView.
     */
    fun updateStatus(message: String) {
        runOnUiThread { APIStatusMessage = message }
    }

    /**
     * Starts an activity in Google Play Services so the user can pick an
     * account.
     */
    private fun chooseAccount() {
        startActivityForResult(
                credential.newChooseAccountIntent(), REQUEST_ACCOUNT_PICKER)
    }

    /**
     * Display an error dialog showing that Google Play Services is missing
     * or out of date.
     * @param connectionStatusCode code describing the presence (or lack of)
     * Google Play Services on this device.
     */
    internal fun showGooglePlayServicesAvailabilityErrorDialog(
            connectionStatusCode: Int) {
        runOnUiThread {
            val dialog = GooglePlayServicesUtil.getErrorDialog(
                    connectionStatusCode,
                    this@MainActivity,
                    REQUEST_GOOGLE_PLAY_SERVICES)
            dialog.show()
        }
    }

    private fun infoPrint(info: Any) {
        println("MAIN_: $info")
    }

    companion object {
        internal val REQUEST_ACCOUNT_PICKER = 1000
        internal val REQUEST_AUTHORIZATION = 1001
        internal val REQUEST_GOOGLE_PLAY_SERVICES = 1002
        private val PREF_ACCOUNT_NAME = "accountName"
        private val SCOPES = arrayOf(CalendarScopes.CALENDAR_READONLY)

        lateinit var centralClock: TextClock

    }

    private inner class SlidingPagerAdapter(fm: FragmentManager): FragmentStatePagerAdapter(fm){
        override fun getCount(): Int = fragments.size
        override fun getItem(p0: Int): Fragment = fragments[p0]
    }
}

@Parcelize
data class Event(val summary: String, val startDate: Date,
                 val endDate: Date, val location: String): Parcelable{
    fun isHappeningNow(): Boolean{
        val now = Date()
        return now.before(startDate)
    }
}