package edu.rit.csh.bettervent.view

import android.accounts.Account
import android.app.admin.DevicePolicyManager
import android.content.ComponentName
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle

import com.google.api.client.googleapis.extensions.android.gms.auth.GoogleAccountCredential

import android.accounts.AccountManager
import android.app.Activity
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.net.ConnectivityManager
import android.opengl.Visibility
import android.os.Parcelable
import android.util.Log
import android.view.View
import android.widget.Toast

import com.google.android.gms.common.ConnectionResult
import com.google.android.gms.common.GooglePlayServicesUtil
import com.google.api.services.calendar.CalendarScopes
import edu.rit.csh.bettervent.AdminReceiver
import edu.rit.csh.bettervent.R
import edu.rit.csh.bettervent.view.companion.CompanionActivity
import edu.rit.csh.bettervent.view.kiosk.EventActivity
import kotlinx.android.parcel.Parcelize
import kotlinx.android.synthetic.main.activity_main.*
import org.jetbrains.anko.alert
import org.jetbrains.anko.okButton
import org.jetbrains.anko.yesButton
import java.util.*

class MainActivity : AppCompatActivity(){
    // This MainActivity gets the data from the API, and holds it
    // as a list. The Fragments then update themselves using that.
    var calendarID: String? = null
    var maxResults: Int = 0

    private lateinit var mAppSettings: SharedPreferences
    private lateinit var apiStatusMessage: String



    /**
     * Checks whether the device currently has a network connection.
     * @return true if the device has a network connection, false otherwise.
     */
    private val isDeviceOnline: Boolean
        get() {
            val connMgr = getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
            val networkInfo = connMgr.activeNetworkInfo
            return networkInfo != null && networkInfo.isConnected
        }

    /**
     * Check that Google Play services APK is installed and up to date. Will
     * launch an error dialog for the user to update Google Play Services if
     * possible.
     * @return true if Google Play Services is available and up to
     * date on this device; false otherwise.
     */
    private val isGooglePlayServicesAvailable: Boolean
        get() {
            val connectionStatusCode = GooglePlayServicesUtil.isGooglePlayServicesAvailable(this)
            if (GooglePlayServicesUtil.isUserRecoverableError(connectionStatusCode)) {
                showGooglePlayServicesAvailabilityErrorDialog(connectionStatusCode)
                return false
            } else if (connectionStatusCode != ConnectionResult.SUCCESS) {
                return false
            }
            return true
        }

    /**
     * Checks the times of the first event in APIOutList (the List of Events generated by the API)
     * and if the current time is within those times, then the room is booked
     * and if the current time is not within those times, the room is free.
     * @return: true if the current time is outside of the time of the
     * next event, and false if vice-versa.
     */


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // Load up app settings to fetch passwords and background colors.
        mAppSettings = applicationContext.getSharedPreferences(
                getString(R.string.preference_file_key), Context.MODE_PRIVATE)!!

        // Must restart for these preferences to take hold.
        calendarID = mAppSettings.getString("edu.rit.csh.bettervent.calendarid", "")
        id_et.setText(calendarID)

        val maxResultsStr = mAppSettings.getString("edu.rit.csh.bettervent.maxresults", "")
        maxResults = if (maxResultsStr !== "" && maxResultsStr != null)
            Integer.parseInt(maxResultsStr)
        else {
            infoPrint("Max Results not set. Defaulting to 100.")
            100
        }

        //Following code allow the app packages to lock task in true kiosk mode
        // get policy manager
        val myDevicePolicyManager = getSystemService(Context.DEVICE_POLICY_SERVICE) as DevicePolicyManager
        // get this app package name
        val mDPM = ComponentName(this, AdminReceiver::class.java)

        if (myDevicePolicyManager.isDeviceOwnerApp(this.packageName)) {
            // get this app package name
            val packages = arrayOf(this.packageName)
            // mDPM is the admin package, and allow the specified packages to lock task
            myDevicePolicyManager.setLockTaskPackages(mDPM, packages)
        } else {
            Toast.makeText(applicationContext, "Not owner", Toast.LENGTH_LONG).show()
        }

        companion_btn.setOnClickListener { startCompanionActivity() }
        kiosk_btn.setOnClickListener { startEventActivity() }
//        startLockTask()
        checkForAccount()
    }

    private fun startCompanionActivity() {
        if (id_et.text.toString().isBlank()) {
            alert{
                title = "You must input a valid calendar ID"
                okButton {  }
            }.show()
            return
        }

        mAppSettings.edit()
                .putString("edu.rit.csh.bettervent.calendarid", id_et.text.toString())
                .apply()

        val intent = Intent(this, CompanionActivity::class.java)
        startActivity(intent)
    }

    private fun startEventActivity() {
        mAppSettings.edit()
                .putString("edu.rit.csh.bettervent.calendarid", id_et.text.toString())
                .apply()

        val intent = Intent(this, EventActivity::class.java)
        startActivity(intent)
    }

    /**
     * Called whenever this activity is pushed to the foreground, such as after
     * a call to onCreate().
     */
    override fun onResume() {
        super.onResume()
        if (!isGooglePlayServicesAvailable) {
            apiStatusMessage = "Google Play Services required: " + "after installing, close and relaunch this app."
        }
    }

    /**
     * Called when an activity launched here (specifically, AccountPicker
     * and authorization) exits, giving you the requestCode you started it with,
     * the resultCode it returned, and any additional data from it.
     * @param requestCode code indicating which activity result is incoming.
     * @param resultCode code indicating the result of the incoming
     * activity result.
     * @param data Intent (containing result data) returned by incoming
     * activity result.
     */
    override fun onActivityResult( requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        infoPrint("API Request code returned: $requestCode")
        when (requestCode) {
            REQUEST_GOOGLE_PLAY_SERVICES -> if (resultCode != Activity.RESULT_OK) {
                isGooglePlayServicesAvailable
            }
            REQUEST_ACCOUNT_PICKER -> {
                infoPrint("Pick your account.")
                if (resultCode == Activity.RESULT_OK && data != null &&
                        data.extras != null) {
                    infoPrint("Result = $resultCode")
                    val accountName = data.getStringExtra(AccountManager.KEY_ACCOUNT_NAME)
                    infoPrint("Account name = " + accountName!!)
                    //                        credential.setSelectedAccountName(accountName);
                    val selectedAccount = Account(accountName, "edu.rit.csh.bettervent")
                    infoPrint("Account name set. Account name = $accountName")
                    infoPrint(selectedAccount.name)
                    val editor = mAppSettings.edit()
                    editor.putString(PREF_ACCOUNT_NAME, accountName)
                    editor.apply()
                    checkForAccount()
                } else if (resultCode == Activity.RESULT_CANCELED) {
                    infoPrint("Account Unspecified")
                    apiStatusMessage = "Account unspecified."
                }
            }
            REQUEST_AUTHORIZATION -> if (resultCode == Activity.RESULT_OK) {
                chooseAccount()
            }
        }

        super.onActivityResult(requestCode, resultCode, data)
    }


    /**
     * Clear any existing Google Calendar API data from the TextView and update
     * the header message; called from background threads and async tasks
     * that need to update the UI (in the UI thread).
     */
    fun clearResultsText() {
        runOnUiThread {
            apiStatusMessage = "Retrieving dataâ€¦"
            apiStatusMessage = ""
        }
    }

    /**
     * Fill the data TextView with the given List of Strings; called from
     * background threads and async tasks that need to update the UI (in the
     * UI thread).
     * @param dataEvents a List of Strings to populate the main TextView with.
     */

    /**
     * Show a status message in the list header TextView; called from background
     * threads and async tasks that need to update the UI (in the UI thread).
     * @param message a String to display in the UI header TextView.
     */
    fun updateStatus(message: String) {
        runOnUiThread { apiStatusMessage = message }
    }

    /**
     * Checks for a signed in account in the app; if one exists, it starts the EventActivity.
     * Otherwise, it allows the user to choose an account
    */

    private fun checkForAccount(){
        val accountName = mAppSettings.getString(PREF_ACCOUNT_NAME, "")!!
        Log.i("MainActivity", "Account Name: $accountName")
        if (accountName.isEmpty()){
            chooseAccount()
            Log.i("MainActivity", "Begin chooseAccount")
        } else {
            enableUI()
        }
    }

    /**
     * Starts an activity in Google Play Services so the user can pick an
     * account.
     */
    private fun chooseAccount() {
        val credential = GoogleAccountCredential.usingOAuth2(applicationContext, SCOPES)
        startActivityForResult(credential.newChooseAccountIntent(), REQUEST_ACCOUNT_PICKER)
    }

    /**
     * Enables the UI to allow the user to choose which version they want to use,
     * Kiosk or Companion
     */
    private fun enableUI() {
        main_root.visibility = View.VISIBLE
    }

    /**
     * Display an error dialog showing that Google Play Services is missing
     * or out of date.
     * @param connectionStatusCode code describing the presence (or lack of)
     * Google Play Services on this device.
     */
    private fun showGooglePlayServicesAvailabilityErrorDialog(
            connectionStatusCode: Int) {
        runOnUiThread {
            val dialog = GooglePlayServicesUtil.getErrorDialog(
                    connectionStatusCode,
                    this@MainActivity,
                    REQUEST_GOOGLE_PLAY_SERVICES)
            dialog.show()
        }
    }

    private fun infoPrint(info: Any) {
        println("MAIN_: $info")
    }

    companion object {
        internal const val REQUEST_ACCOUNT_PICKER = 1000
        internal const val REQUEST_AUTHORIZATION = 1001
        internal const val REQUEST_GOOGLE_PLAY_SERVICES = 1002
        private const val PREF_ACCOUNT_NAME = "accountName"
        val SCOPES = arrayListOf(CalendarScopes.CALENDAR_READONLY)
    }
}

data class Event(val summary: String, val start: Date,
                 val end: Date, val location: String)
{
    val isHappeningNow = hasStarted and !isOver

    private val isOver: Boolean
        get() {
            val now = Date()
            return now.after(end)
        }


    private val hasStarted: Boolean
        get(){
            val now = Date()
            return start.before(now)
        }
}