package edu.rit.csh.bettervent.view

import android.accounts.Account
import android.app.admin.DevicePolicyManager
import android.content.ComponentName
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle

import com.google.api.client.googleapis.extensions.android.gms.auth.GoogleAccountCredential

import android.accounts.AccountManager
import android.app.Activity
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.net.ConnectivityManager
import android.util.Log
import android.view.View
import android.widget.Toast
import com.google.android.gms.auth.GoogleAuthUtil
import com.google.android.gms.auth.UserRecoverableAuthException
import com.google.android.gms.auth.api.signin.GoogleSignIn
import com.google.android.gms.auth.api.signin.GoogleSignInAccount
import com.google.android.gms.auth.api.signin.GoogleSignInClient
import com.google.android.gms.auth.api.signin.GoogleSignInOptions

import com.google.android.gms.common.ConnectionResult
import com.google.android.gms.common.GooglePlayServicesUtil
import com.google.android.gms.common.Scopes
import com.google.android.gms.common.api.ApiException
import com.google.android.gms.common.api.Scope
import com.google.android.gms.tasks.Task
import com.google.api.client.googleapis.auth.oauth2.GoogleAuthorizationCodeTokenRequest
import com.google.api.client.util.ExponentialBackOff
import com.google.api.services.calendar.CalendarScopes
import edu.rit.csh.bettervent.AdminReceiver
import edu.rit.csh.bettervent.R
import edu.rit.csh.bettervent.view.companion.CompanionActivity
import edu.rit.csh.bettervent.view.kiosk.MainActivity
import kotlinx.android.synthetic.main.activity_main.*
import org.jetbrains.anko.alert
import org.jetbrains.anko.okButton
import org.jetbrains.anko.startActivityForResult
import java.util.*

class MainActivity : AppCompatActivity(){
    // This MainActivity gets the data from the API, and holds it
    // as a list. The Fragments then update themselves using that.
    var calendarID: String? = null

    private lateinit var mAppSettings: SharedPreferences
    private lateinit var apiStatusMessage: String
    lateinit var signInClient: GoogleSignInClient


    /**
     * Check that Google Play services APK is installed and up to date. Will
     * launch an error dialog for the user to update Google Play Services if
     * possible.
     * @return true if Google Play Services is available and up to
     * date on this device; false otherwise.
     */
    private val isGooglePlayServicesAvailable: Boolean
        get() {
            val connectionStatusCode = GooglePlayServicesUtil.isGooglePlayServicesAvailable(this)
            if (GooglePlayServicesUtil.isUserRecoverableError(connectionStatusCode)) {
                showGooglePlayServicesAvailabilityErrorDialog(connectionStatusCode)
                return false
            } else if (connectionStatusCode != ConnectionResult.SUCCESS) {
                return false
            }
            return true
        }

    /**
     * Checks the times of the first event in APIOutList (the List of Events generated by the API)
     * and if the current time is within those times, then the room is booked
     * and if the current time is not within those times, the room is free.
     * @return: true if the current time is outside of the time of the
     * next event, and false if vice-versa.
     */


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // Load up app settings to fetch passwords and background colors.
        mAppSettings = applicationContext.getSharedPreferences(
                getString(R.string.preference_file_key), Context.MODE_PRIVATE)!!

        // Must restart for these preferences to take hold.
        calendarID = mAppSettings.getString("edu.rit.csh.bettervent.calendarid", "")
        id_et.setText(calendarID)


        //Following code allow the app packages to lock task in true kiosk mode
        // get policy manager
        val myDevicePolicyManager = getSystemService(Context.DEVICE_POLICY_SERVICE) as DevicePolicyManager
        // get this app package name
        val mDPM = ComponentName(this, AdminReceiver::class.java)

        if (myDevicePolicyManager.isDeviceOwnerApp(this.packageName)) {
            // get this app package name
            val packages = arrayOf(this.packageName)
            // mDPM is the admin package, and allow the specified packages to lock task
            myDevicePolicyManager.setLockTaskPackages(mDPM, packages)
        } else {
            Toast.makeText(applicationContext, "Not owner", Toast.LENGTH_LONG).show()
        }

        val gso = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
                .requestScopes(Scope("https://www.googleapis.com/auth/calendar.readonly"))
                .requestEmail()
                .build()

        signInClient = GoogleSignIn.getClient(this, gso)

        companion_btn.setOnClickListener { startCompanionActivity() }
        kiosk_btn.setOnClickListener { startEventActivity() }
//        startLockTask()
        checkForAccount()

        choose_account_btn.setOnClickListener { signOutThenIn() }
    }

    private fun startCompanionActivity() {
        if (id_et.text.toString().isBlank()) {
            alert{
                title = "You must input a valid calendar ID"
                okButton {  }
            }.show()
            return
        }

        mAppSettings.edit()
                .putString("edu.rit.csh.bettervent.calendarid", id_et.text.toString())
                .apply()

        val intent = Intent(this, CompanionActivity::class.java)
        startActivity(intent)
    }

    private fun startEventActivity() {
        if (id_et.text.toString().isBlank()) {
            alert{
                title = "You must input a valid calendar ID"
                okButton {  }
            }.show()
            return
        }
        
        mAppSettings.edit()
                .putString("edu.rit.csh.bettervent.calendarid", id_et.text.toString())
                .apply()

        val intent = Intent(this, MainActivity::class.java)
        startActivity(intent)
    }

    /**
     * Called when an activity launched here (specifically, AccountPicker
     * and authorization) exits, giving you the requestCode you started it with,
     * the resultCode it returned, and any additional data from it.
     * @param requestCode code indicating which activity result is incoming.
     * @param resultCode code indicating the result of the incoming
     * activity result.
     * @param data Intent (containing result data) returned by incoming
     * activity result.
     */
    override fun onActivityResult( requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        infoPrint("API Request code returned: $requestCode")
        when (requestCode) {
            REQUEST_GOOGLE_PLAY_SERVICES -> if (resultCode != Activity.RESULT_OK) {
                isGooglePlayServicesAvailable
            }
            RC_SIGN_IN -> {
                val task = GoogleSignIn.getSignedInAccountFromIntent(data)
                handleSignInResult(task)
            }
        }

        super.onActivityResult(requestCode, resultCode, data)
    }

    private fun handleSignInResult(task: Task<GoogleSignInAccount>){
        try {
            val account = task.getResult(ApiException::class.java)
            mAppSettings.edit().putString(PREF_ACCOUNT_NAME, account?.email).apply()
            checkForAccount()
        } catch(e: ApiException){
            Log.w("MainActivity", "signInResult failed; code=${e.statusCode}")
        }
    }

    private fun signIn(){
        startActivityForResult(signInClient.signInIntent, RC_SIGN_IN)
    }

    /**
     * Allow the user to change accounts
     */

    private fun signOutThenIn(){
        signInClient.signOut()
                .addOnCompleteListener { signIn() }
    }

    /**
     * Checks for a signed in account in the app; if one exists, it starts the MainActivity.
     * Otherwise, it allows the user to choose an account
    */

    private fun checkForAccount(){
        val accountName = mAppSettings.getString(PREF_ACCOUNT_NAME, "")!!
        account_name_tv.text = accountName

        if (accountName.isEmpty()){
            signIn()
            Log.i("MainActivity", "Begin chooseAccount")
        } else {
            enableUI()
        }
    }

    /**
     * Enables the UI to allow the user to choose which version they want to use,
     * Kiosk or Companion
     */
    private fun enableUI() {
        main_root.visibility = View.VISIBLE
    }

    /**
     * Display an error dialog showing that Google Play Services is missing
     * or out of date.
     * @param connectionStatusCode code describing the presence (or lack of)
     * Google Play Services on this device.
     */
    private fun showGooglePlayServicesAvailabilityErrorDialog(
            connectionStatusCode: Int) {
        runOnUiThread {
            val dialog = GooglePlayServicesUtil.getErrorDialog(
                    connectionStatusCode,
                    this@MainActivity,
                    REQUEST_GOOGLE_PLAY_SERVICES)
            dialog.show()
        }
    }

    private fun infoPrint(info: Any) {
        println("MAIN_: $info")
    }

    companion object {
        internal const val REQUEST_ACCOUNT_PICKER = 1000
        internal const val RC_SIGN_IN = 1001
        internal const val REQUEST_GOOGLE_PLAY_SERVICES = 1002
        private const val PREF_ACCOUNT_NAME = "accountName"
        val SCOPES = arrayOf(CalendarScopes.CALENDAR_READONLY)
    }
}

data class Event(val summary: String, val start: Date,
                 val end: Date, val location: String)
{
    val isHappeningNow = hasStarted and !isOver

    private val isOver: Boolean
        get() {
            val now = Date()
            return now.after(end)
        }


    private val hasStarted: Boolean
        get(){
            val now = Date()
            return start.before(now)
        }
}